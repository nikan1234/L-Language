options {
  STATIC = false;
  MULTI = true;
  NODE_DEFAULT_VOID=true;
  NODE_PREFIX = "";
}

PARSER_BEGIN(LStatement)
package ru.nsu.logic.lang.grammar;

import java.util.*;
import ru.nsu.logic.lang.grammar.common.*;
public class LStatement {}
PARSER_END(LStatement)

SKIP : {
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN : {
  < CLASS: "class">
  |
  < FUNCTION: "function">
  |
  < INHERIT: "extends">
  |
  < END: ";">
  |
  < OBR: "{" >
  |
  < CBR: "}" >
  |
  < OPAR  : "(" >
  |
  < CPAR  : ")" >
  |
  < OAR: "[">
  |
  < CAR: "]">
  |
  < COMMA: "," >
  |
  < DOT: "." >
  |
  < ARROW: "==>" >
  |
  < COND: "cond" >
  |
  < ASSIGN: ":=" >
  |
  < THIS: "this" >
  |
  < NULL: "nil" >
  |
  < RETURN: "return" >
  |
  < ACCESS_PUBLIC: "public" >
  |
  < ACCESS_PRIVATE: "private" >
  |
  < ACCESS_PROTECTED: "protected" >
  |
  < LOGIC_AND: "and" >
  |
  < LOGIC_OR: "or" >
  |
  < LOGIC_NOT: "not" >
  |
  < IDENTIFIER: ["a"-"z","A"-"Z", "_"] ( ["a"-"z","A"-"Z","0"-"9","_"] )* >
  |
  < BINARY_OP: ["+", "-", "*", "/"] >
  |
  < FOR_ALL: "forall" >
  |
  < EXISTS: "exists" >
  |
  < IN: "in" >
  |
  < SUBSETEQ: "subseteq" >
  |
  < EQ: "=" >
  |
  < NE: "<>" >
  |
  < LT: "<" >
  |
  < GT: ">" >
  |
  < LE: "<=" >
  |
  < GE: ">=" >
  |
  < INT_VAL: ( ["0"-"9"] )+ >
  |
  < FLT_VAL: ( ["0"-"9"] )+ "." ( ["0"-"9"] )+  >
  |
  < STR_VAL: "\"" (~["\""])* "\"" >
}

LLangProgram LLangProgram() #LLangProgram :
{}
{
  (AllDeclarations() | AllStatements())* <EOF>
  {return jjtThis;}
}

////////////////////////////////////////////////////////
//                       Common                       //
////////////////////////////////////////////////////////

AccessTypeEnum AccessType() :
{Token t;}
{
  (t=<ACCESS_PUBLIC> | t=<ACCESS_PRIVATE> | t=<ACCESS_PROTECTED>)
  {return AccessTypeEnum.valueOf(t.image.toUpperCase());}
}

Token Identifier() :
{Token t;}
{
  t=<IDENTIFIER> {return t;}
}


////////////////////////////////////////////////////////
//                    Declarations                    //
////////////////////////////////////////////////////////

void AllDeclarations():
{}
{
  FunctionDeclaration() | ClassDeclaration()
}

String ArgumentDeclaration() # ArgumentDeclaration :
{Token arg;}
{
  arg=Identifier()
  {
    jjtThis.jjtSetValue(arg.image);
    jjtThis.setLocation(new FileLocation(arg.beginLine, arg.beginColumn));
    return arg.image;
  }
}

// 1. Function Declaration

void FunctionDeclaration() #FunctionDeclaration :
{Token functionName;}
{
  <FUNCTION> functionName=Identifier()
  <OPAR> (ArgumentDeclaration() (<COMMA> ArgumentDeclaration())*)? <CPAR>
  <OBR> (AllStatements())* <CBR>
  {
    jjtThis.setName(functionName.image);
    jjtThis.setLocation(new FileLocation(functionName.beginLine, functionName.beginColumn));
  }
}

// 2. Class Declaration

Token InheritanceDeclaration() :
{Token className;}
{
  <INHERIT> className=Identifier()
  {return className;}
}

void ClassDeclaration() #ClassDeclaration :
{Token className; Token baseClass = null;}
{
  <CLASS> className=Identifier() [baseClass=InheritanceDeclaration()]
  <OBR> (LOOKAHEAD(2) ClassMemberDeclaration() | ClassMethodDeclaration())*
  <CBR>
  {
    jjtThis.setClassName(className.image);
    jjtThis.setBaseClass(baseClass != null ? baseClass.image : null);
    jjtThis.setLocation(new FileLocation(className.beginLine, className.beginColumn));
  }
}

void ClassMemberDeclaration() #ClassMemberDeclaration :
{AccessTypeEnum access; Token member;}
{
  access=AccessType() member=Identifier() <END>
  {
    jjtThis.setAccessType(access);
    jjtThis.setName(member.image);
    jjtThis.setLocation(new FileLocation(member.beginLine, member.beginColumn));
  }
}

void ClassMethodDeclaration() #ClassMethodDeclaration :
{AccessTypeEnum access = AccessTypeEnum.PROTECTED; Token methodName;}
{
  [access = AccessType()] <FUNCTION> methodName=Identifier()
  <OPAR> (ArgumentDeclaration() (<COMMA> ArgumentDeclaration())*)? <CPAR>
  <OBR> (AllStatements())* <CBR>
  {
    jjtThis.setAccessType(access);
    jjtThis.setName(methodName.image);
    jjtThis.setLocation(new FileLocation(methodName.beginLine, methodName.beginColumn));
  }
}


////////////////////////////////////////////////////////
//                       Formulas                     //
////////////////////////////////////////////////////////

ComparisonOperator CmpOp() :
{}
{
  <EQ> {return ComparisonOperator.EQ;} |
  <NE> {return ComparisonOperator.NE;} |
  <LT> {return ComparisonOperator.LT;} |
  <LE> {return ComparisonOperator.LE;} |
  <GT> {return ComparisonOperator.GT;} |
  <GE> {return ComparisonOperator.GE;}
}

ComparisonFormula ComparisonFormula() # ComparisonFormula :
{IStatement lhs; IStatement rhs; ComparisonOperator cmp;}
{
   lhs = Statement() cmp=CmpOp() rhs = Statement()
   {
     jjtThis.setLeft(lhs);
     jjtThis.setRight(rhs);
     jjtThis.setOperator(cmp);
     return jjtThis;
   }
}

IFormula Formula() :
{IFormula retVal;}
{
   retVal=ComparisonFormula()
   { return retVal; }
}


////////////////////////////////////////////////////////
//                     L*-features                    //
////////////////////////////////////////////////////////

// 1. Cond

CondStatement CondStatement() # CondStatement :
{Token t; IFormula formula; IStatement statement;
 List<IFormula> formulas = new ArrayList(); List<IStatement> statements = new ArrayList();}
{
   t=<COND> <OPAR>
   ((LOOKAHEAD(Formula() <ARROW>) formula=Formula() <ARROW> statement=Statement() <COMMA>
    {formulas.add(formula);statements.add(statement);})+
    statement=Statement() {statements.add(statement);})
   <CPAR>
   {
     jjtThis.setFormulas(formulas);
     jjtThis.setStatements(statements);
     jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn));
     return jjtThis;
   }
}

// 2. Iteration
// TODO


////////////////////////////////////////////////////////
//                      Statement                     //
////////////////////////////////////////////////////////

// 1. Types

NumberValue NumberVal() #NumberValue :
{Token t;}
{
  t=<INT_VAL> { jjtThis.setNumber(Long.valueOf(t.image));   jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn)); return jjtThis; } |
  t=<FLT_VAL> { jjtThis.setNumber(Double.valueOf(t.image)); jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn)); return jjtThis; }
}

NullValue NullVal() #NullValue :
{Token t;}
{
  t=<NULL>
  {
    return jjtThis;
    jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn));
  }
}

ListValue ListVal() #ListValue :
{Token t; IStatement element; List<IStatement> elements = new ArrayList();}
{
    t = <OAR>
      (        element=Statement() {elements.add(element);}
      (<COMMA> element=Statement() {elements.add(element);} )*)?
    <CAR>
    {
      jjtThis.setElements(elements);
      jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn));
      return jjtThis;
    }
}

// 2. Var and member

MemberStatement MemberStatement() # MemberStatement :
{Token t;  Token memberName;}
{
  t=<THIS> <DOT> memberName=Identifier()
  {
    jjtThis.setName(memberName.image);
    jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn));
    return jjtThis;
  }
}

VariableStatement VariableStatement() # VariableStatement :
{Token varName;}
{
  varName=Identifier()
  {
    jjtThis.setName(varName.image);
    jjtThis.setLocation(new FileLocation(varName.beginLine, varName.beginColumn));
    return jjtThis;
  }
}

// 3. Right-value statements (function call, arithmetic expression, e.t.c.)

FunctionCallStatement FunctionCallStatement() # FunctionCallStatement:
{Token calledFuncName; IStatement param; List<IStatement> params = new ArrayList();}
{
   calledFuncName=Identifier()
   <OPAR>
      (param=Statement()         { params.add(param); }
      (<COMMA> param=Statement() { params.add(param); } )*)?
   <CPAR>
   {
     jjtThis.setFunctionName(calledFuncName.image);
     jjtThis.setCallParameters(params);
     jjtThis.setLocation(new FileLocation(calledFuncName.beginLine, calledFuncName.beginColumn));
     return jjtThis;
    }
}

IStatement SingleStatement() :
{IStatement retVal;}
{
  (
    LOOKAHEAD(2) retVal = CondStatement() |
    LOOKAHEAD(2) retVal = FunctionCallStatement() |
    retVal=MemberStatement() | retVal=VariableStatement() |
    retVal=ListVal() | retVal=NumberVal() | retVal=NullVal()
  )
  { return retVal; }
}

ArithmeticStatement ArithmeticStatement() # ArithmeticStatement :
{IStatement lhs = null; 
 IStatement rhs = null; 
 Token op = null;
 List<IStatement> args = new ArrayList();
 List<String> ops = new ArrayList();
}
{ (                (lhs=SingleStatement() | <OPAR> lhs=ArithmeticStatement() <CPAR>) { args.add(lhs); }
   (op=<BINARY_OP> (rhs=SingleStatement() | <OPAR> rhs=ArithmeticStatement() <CPAR>) { args.add(rhs); ops.add(op.image); })+)
  {
    jjtThis.setOperands(args);
    jjtThis.setOperators(ops);
    return jjtThis;
  }
}

IStatement Statement():
{IStatement retVal;}
{
  (LOOKAHEAD((<OPAR> ArithmeticStatement() <CPAR> | SingleStatement()) <BINARY_OP>) retVal = ArithmeticStatement() |
   retVal = SingleStatement())
  { return retVal; }
}

// 4. Assignment, return

void AllStatements() :
{}
{
  (LOOKAHEAD(2) AssignmentStatement() | FunctionCallStatement() | ReturnStatement()) <END>
}

void AssignmentStatement() # AssignmentStatement :
{Token t; IStatement target; IStatement what;}
{
  (target=MemberStatement() | target=VariableStatement())
  t = <ASSIGN> what = Statement()
  {
    jjtThis.setTarget(target);
    jjtThis.setWhat(what);
    jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn));
  }
}

void ReturnStatement() # ReturnStatement :
{Token t; IStatement what;}
{
  t = <RETURN> what=Statement()
  {
    jjtThis.setWhat(what);
    jjtThis.setLocation(new FileLocation(t.beginLine, t.beginColumn));
  }
}
